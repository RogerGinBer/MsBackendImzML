# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Generic method for the imzMLreader
#' testingimzMLBinRead
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param N: number of elemetns (or data point to read).
#' @param offset: offset in bytes at which the reading operation is started.
#' @param read_mz: if true m/z data is readed, otherwise intensities are readed.
#' @param continuous: true if imzML data is in continuous mode
imzMLBinReadGeneric <- function(ibdFname, NPixels, N, offset, dataTypeString, read_mz, continuous) {
    .Call('_MsBackendImzML_imzMLBinReadGeneric', PACKAGE = 'MsBackendImzML', ibdFname, NPixels, N, offset, dataTypeString, read_mz, continuous)
}

#' Testing the imzMLwriter in sequential mode
#' This function creates a new ibd file with the provided data descibed in the following params
#' @param ibdFname: full path to the ibd file.
#' @param mz_dataTypeString: String to specify the data format used to encode m/z values.
#' @param int_dataTypeString: String to specify the data format used to encode intensity values.
#' @param uuid: 16 bytes long UUID.
#' @param mzArray: A matrix with the m/z values for all pixels. Each pixel corresponds to a row. If there is only one row data will be saved in continuous mode
#' @param intArray: A matrix with the intensity values for all pixels. Each pixel corresponds to a row so the number of pixels is extracted from here.
.debug_imzMLBinWriterSequential <- function(ibdFname, mz_dataTypeString, int_dataTypeString, str_uuid, mzArray, intArray) {
    .Call('_MsBackendImzML_testingimzMLBinWriteSequential', PACKAGE = 'MsBackendImzML', ibdFname, mz_dataTypeString, int_dataTypeString, str_uuid, mzArray, intArray)
}

#' CimzMLBinCreateNewIBD.
#' This function creates a new ibd file with the provided uuid
#' @param ibdFname: full path to the ibd file.
#' @param uuid: 16 bytes long UUID.
CimzMLBinCreateNewIBD <- function(ibdFname, str_uuid) {
    invisible(.Call('_MsBackendImzML_CimzMLBinCreateNewIBD', PACKAGE = 'MsBackendImzML', ibdFname, str_uuid))
}

#' CimzMLBinAppendMass.
#' This function appends a new mass axis to a given ibd file.
#' The last added offset is returned.
#' @param ibdFname: full path to the ibd file.
#' @param mz_dataTypeString:  String to specify the data format used to encode m/z values.
#' @param mzNew: The mass axis to append.
CimzMLBinAppendMass <- function(ibdFname, mz_dataTypeString, mzNew) {
    .Call('_MsBackendImzML_CimzMLBinAppendMass', PACKAGE = 'MsBackendImzML', ibdFname, mz_dataTypeString, mzNew)
}

#' CimzMLBinAppendIntensity.
#' This function appends a new mass axis to a given ibd file.
#' The last added offset is returned.
#' @param ibdFname: full path to the ibd file.
#' @param int_dataTypeString:  String to specify the data format used to encode m/z values.
#' @param intNew: The mass axis to append.
CimzMLBinAppendIntensity <- function(ibdFname, int_dataTypeString, intNew) {
    .Call('_MsBackendImzML_CimzMLBinAppendIntensity', PACKAGE = 'MsBackendImzML', ibdFname, int_dataTypeString, intNew)
}

#' A method to use the imzMLwriter in modify mode to allow direct modification of mass axes for the calibration
#' This function modifies data of an ibd file with the following params
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param mz_dataTypeString: String to specify the data format used to encode m/z values.
#' @param int_dataTypeString: String to specify the data format used to encode intensity values.
#' @param continuous: true if imzML data is in continuous mode
#' @param mzNew: A vector with the m/z values. Must be the same length as the original imzML mass target massa axis.
#' @param mzOffset: offset in the ibd file of the target mass axis.
CimzMLBinWriteModifyMass <- function(ibdFname, NPixels, mz_dataTypeString, int_dataTypeString, continuous, mzNew, mzOffset) {
    invisible(.Call('_MsBackendImzML_CimzMLBinWriteModifyMass', PACKAGE = 'MsBackendImzML', ibdFname, NPixels, mz_dataTypeString, int_dataTypeString, continuous, mzNew, mzOffset))
}

#' CimzMLBinReadMass.
#' 
#' Reads a single mass axis from the imzML file.
#' 
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param N: number of elemetns (or data point to read).
#' @param offset: offset in bytes at which the reading operation is started.
#' @param continuous: true if imzML data is in continuous mode
CimzMLBinReadMass <- function(ibdFname, NPixels, N, offset, dataTypeString, continuous) {
    .Call('_MsBackendImzML_CimzMLBinReadMass', PACKAGE = 'MsBackendImzML', ibdFname, NPixels, N, offset, dataTypeString, continuous)
}

#' CimzMLBinReadIntensity.
#' 
#' Reads a single mass axis from the imzML file.
#' 
#' @param ibdFname: full path to the ibd file.
#' @param NPixels: Total number of pixels in the image.
#' @param N: number of elemetns (or data point to read).
#' @param offset: offset in bytes at which the reading operation is started.
#' @param continuous: true if imzML data is in continuous mode
CimzMLBinReadIntensity <- function(ibdFname, NPixels, N, offset, dataTypeString, continuous) {
    .Call('_MsBackendImzML_CimzMLBinReadIntensity', PACKAGE = 'MsBackendImzML', ibdFname, NPixels, N, offset, dataTypeString, continuous)
}

#' Method to read a peak list from an imzML file. Processed mode is assumed.
#' testingimzMLBinRead
#' @param ibdFname: full path to the ibd file.
#' @param imzML_peakList_descriptor: imzML file description as it is returned by the CimzMLParse() function.
#' @param PixelID: the pixel ID to read a peak list.
CimzMLReadPeakList <- function(ibdFname, imzML_peakList_descriptor, PixelID) {
    .Call('_MsBackendImzML_CimzMLReadPeakList', PACKAGE = 'MsBackendImzML', ibdFname, imzML_peakList_descriptor, PixelID)
}

#' Method to overwrite the UUID of an imzML ibd file.
#' testingimzMLBinRead
#' @param ibdFname: full path to the ibd file.
#' @param newUUID: the new uuid as a string.
overwriteIbdUUid <- function(ibdFname, newUUID) {
    invisible(.Call('_MsBackendImzML_overwriteIbdUUid', PACKAGE = 'MsBackendImzML', ibdFname, newUUID))
}

#' Cload_imzMLSpectra
#' Load spectra into a Matrix object interpolating to the common mass axis when necessary.
#' @param rMSIobj: an rMSI object prefilled with a parsed imzML.
#' @param pixelIDs: pixel ID's of the spectra to load in C-style indexing (starting at 0).
#' @param commonMassAxis: a common mass axis that may be different than the mass axis in the rMSI object.
#' @param number_of_threads: number of thread to use during interpolation
Cload_imzMLSpectra <- function(rMSIobj, pixelIDs, commonMassAxis, number_of_threads) {
    .Call('_MsBackendImzML_Cload_imzMLSpectra', PACKAGE = 'MsBackendImzML', rMSIobj, pixelIDs, commonMassAxis, number_of_threads)
}

CimzMLParse <- function(xml_path) {
    .Call('_MsBackendImzML_CimzMLParse', PACKAGE = 'MsBackendImzML', xml_path)
}

CimzMLStore <- function(fname, imgInfo, mass_spectrometer_file_format = "rMSI exported imzML") {
    .Call('_MsBackendImzML_CimzMLStore', PACKAGE = 'MsBackendImzML', fname, imgInfo, mass_spectrometer_file_format)
}

#' NoiseEstimationFFTCosWin.
#' 
#' Estimate the noise of a spectrum using a FFT filter and a cosinus window in frequency domain.
#' 
#' @param x an Rcpp::NumericVector containing the spectrum intensities.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericVector containing the estimated noise.
#' @export
NoiseEstimationFFTCosWin <- function(x, filWinSize = 40L) {
    .Call('_MsBackendImzML_NoiseEstimationFFTCosWin', PACKAGE = 'MsBackendImzML', x, filWinSize)
}

#' NoiseEstimationFFTExpWin.
#' 
#' Estimate the noise of a spectrum using a FFT filter and a decay exponential window in frequency domain.
#' 
#' @param x an Rcpp::NumericVector containing the spectrum intensities.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericVector containing the estimated noise.
#' @export
NoiseEstimationFFTExpWin <- function(x, filWinSize = 40L) {
    .Call('_MsBackendImzML_NoiseEstimationFFTExpWin', PACKAGE = 'MsBackendImzML', x, filWinSize)
}

#' NoiseEstimationFFTCosWinMat.
#' 
#' Estimate the noise of some spectra using a FFT filter and a cosinus window in frequency domain.
#' 
#' @param x an Rcpp::NumericMatrix containing the spectra intensities. Each spectrum in a row.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericMatrix containing the estimated noise in a matrix where each spectrum is a row.
#' @export
NoiseEstimationFFTCosWinMat <- function(x, filWinSize = 40L) {
    .Call('_MsBackendImzML_NoiseEstimationFFTCosWinMat', PACKAGE = 'MsBackendImzML', x, filWinSize)
}

#' NoiseEstimationFFTExpWinMat.
#' 
#' Estimate the noise of some spectra using a FFT filter and a decay exponential window in frequency domain.
#' 
#' @param x an Rcpp::NumericMatrix containing the spectra intensities. Each spectrum in a row.
#' @param filWinSize an integer specified the cosinus win size in samples.
#' 
#' @return an Rcpp::NumericMatrix containing the estimated noise in a matrix where each spectrum is a row.
#' @export
NoiseEstimationFFTExpWinMat <- function(x, filWinSize = 40L) {
    .Call('_MsBackendImzML_NoiseEstimationFFTExpWinMat', PACKAGE = 'MsBackendImzML', x, filWinSize)
}

#' DetectPeaks_C.
#' 
#' Detect peaks from a Rcpp::NumericVector object and returns data in a R matrix.
#' This method is only exported to be use by R function DetectPeaks which is an actual R function.
#' The returned peak positions follows C indexing style, this is starts with zero.
#' 
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param intensity a NumericVector where peaks must be detected.
#' @param SNR Only peaks with an equal or higher SNR are retained.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumerixMatrix of 5 rows corresponding to: mass, intensity of the peak, SNR, area and binSize.
#' 
DetectPeaks_C <- function(mass, intensity, SNR = 5, WinSize = 20L, UpSampling = 10L) {
    .Call('_MsBackendImzML_DetectPeaks_C', PACKAGE = 'MsBackendImzML', mass, intensity, SNR, WinSize, UpSampling)
}

#' TestPeakInterpolation_C.
#' 
#' 
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param intensity a NumericVector where peaks must be detected.
#' @param peakIndex the location of the peak to interpolate in the spectrum.  
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' @param useHanning if hanning windowing must be used befor interpolation.
#' @param Iterations number of iterations to perform. This is just for testing interpolation efficiency
#' 
#' @return a NumerixVector with the FFT interpolated peak shape.
#' 
TestPeakInterpolation_C <- function(mass, intensity, peakIndex, WinSize = 20L, UpSampling = 10L, useHanning = FALSE, Iterations = 1L) {
    .Call('_MsBackendImzML_TestPeakInterpolation_C', PACKAGE = 'MsBackendImzML', mass, intensity, peakIndex, WinSize, UpSampling, useHanning, Iterations)
}

#' TestHanningWindow.
#' 
#' Method to test the implementation of Hanning window in R session.
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumericVector containing the Hanning Window.
#' 
TestHanningWindow <- function(mass, WinSize = 20L, UpSampling = 10L) {
    .Call('_MsBackendImzML_TestHanningWindow', PACKAGE = 'MsBackendImzML', mass, WinSize, UpSampling)
}

#' TestAreaWindow.
#' 
#' Method to test the implementation of Area window in R session.
#' @param mass a NumericVector containing the mass axis of the spectrum.
#' @param WinSize The windows used to detect peaks and caculate noise.
#' @param UpSampling the oversampling used for acurate mass detection and area integration.
#' 
#' @return a NumericVector containing the Area Window.
#' 
TestAreaWindow <- function(mass, WinSize = 20L, UpSampling = 10L) {
    .Call('_MsBackendImzML_TestAreaWindow', PACKAGE = 'MsBackendImzML', mass, WinSize, UpSampling)
}

